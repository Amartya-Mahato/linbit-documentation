<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch-lvm">
  <title>Using LVM with DRBD</title>
  <para><indexterm>
      <primary>LVM</primary>
    </indexterm>
    <indexterm>
      <primary>Logical Volume Management</primary>
      <see>LVM</see>
    </indexterm>This chapter deals with managing DRBD in conjunction
    with LVM2. In particular, it covers
    <itemizedlist>
      <listitem>
	<para>using LVM Logical Volumes as backing devices for
	  DRBD;</para>
      </listitem>
      <listitem>
	<para>using DRBD devices as Physical Volumes for LVM;</para>
      </listitem>
      <listitem>
	<para>combining these to concepts to implement a layered LVM
	  approach using DRBD.</para>
      </listitem>
    </itemizedlist>
  </para>
  <para>If you happen to be unfamiliar with these terms to begin with,
    <xref linkend="s-lvm-primer"/> may serve as your LVM starting
    point &mdash; although you are always encouraged, of course, to
    familiarize yourself with LVM in some more detail than this
    section provides.</para>
  <section id="s-lvm-primer">
    <title>LVM primer</title>
    <para>LVM2 is an implementation of logical volume management in
      the context of the Linux device mapper framework. It has
      practically nothing in common, other than the name and acronym,
      with the original LVM implementation. The old implementation
      (now retroactively named "LVM1") is considered obsolete; it is
      not covered in this section.</para>
    <para>When working with LVM, it is important to understand its
      most basic concepts:
	<itemizedlist>
	<listitem>
	  <formalpara>
	    <title>Physical Volume (PV)</title>
	    <indexterm>
	      <primary>LVM</primary>
	      <secondary>Physical Volume (PV)</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Physical Volume (LVM)</primary>
	    </indexterm>
	    <para>A PV is an underlying block device exclusively
	      managed by LVM. PVs can either be entire hard disks or
	      individual partitions. It is common practice to create a
	      partition table on the hard disk where one partition is
	      dedicated to the use by the Linux LVM.
	      <note>
		<para>The partition type "Linux LVM" (signature
		  <code>0x8E</code>) can be used to identify
		  partitions for exclusive use by LVM. This, however,
		  is not required &mdash; LVM recognizes PVs by way of
		  a signature written to the device upon PV
		  initialization.</para>
	      </note>
	    </para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Volume Group (VG)</title>
	    <indexterm>
	      <primary>LVM</primary>
	      <secondary>Volume Group (VG)</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Volume Group (LVM)</primary>
	    </indexterm>
	    <para>A VG is the basic administrative unit of the LVM. A
	      VG may include one or more several PVs. Every VG has a
	      unique name. A VG may be extended during runtime by
	      adding additional PVs, or by enlarging an existing PV.</para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Logical Volume (LV)</title>
	    <indexterm>
	      <primary>LVM</primary>
	      <secondary>Logical Volume (LV)</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Logical Volume (LVM)</primary>
	    </indexterm>
	    <para>LVs may be created during runtime within VGs and are
	      available to the other parts of the kernel as regular
	      block devices. As such, they may be used to hold a file
	      system, or for any other purpose block devices may be
	      used for. LVs may be resized while they are online, and
	      they may also be moved from one PV to another (as long
	      as the PVs are part of the same VG).</para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Snapshot Logical Volume (SLV)</title>
	    <indexterm>
	      <primary>snapshots (LVM)</primary>
	    </indexterm>
	    <indexterm>
	      <primary>LVM</primary>
	      <secondary>snapshots</secondary>
	    </indexterm>
	    <para>Snapshots are temporary point-in-time copies of LVs.
	      Creating snapshots is an operation that completes almost
	      instantly, even if the original LV (the <emphasis>origin
		volume</emphasis>) has a size of several hundred
	      GiByte. Usually, a snapshot requires significantly less
	      space than the original LV.</para>
	  </formalpara>
	</listitem>
	</itemizedlist>
	<figure id="f-lvm-overview">
	<title>LVM overview</title>
	<mediaobject>
	  <imageobject>
	    <imagedata width="100%" contentdepth="100%" scalefit="1" fileref="lvm"/>
	  </imageobject>
	</mediaobject>
	</figure>
    </para>
    </section>
  <section id="s-lvm-lv-as-drbd-backing-dev">
    <title>Using a Logical Volume as a DRBD backing device</title>
    <para><indexterm>
	<primary>LVM</primary>
	<secondary>Logical Volume (LV)</secondary>
    </indexterm>
    <indexterm>
	<primary>Logical Volume (LVM)</primary>
    </indexterm>Since an existing Logical Volume is simply a block
      device in Linux terms, you may of course use it as a DRBD
      backing device. To use LV's in this manner, you simply create
      them, and then initialize them for DRBD as you normally
      would.</para>
    <para>This example assumes that a Volume Group named
      <code>foo</code> already exists on both nodes of on your
      LVM-enabled system, and that you wish to create a DRBD resource
      named <code>r0</code> using a Logical Volume in that Volume
      Group.</para>
    <para>First, you create the Logical Volume:
      <indexterm>
	<primary>LVM</primary>
	<secondary>lvcreate command</secondary>
      </indexterm>
      <indexterm>
	<primary>lvcreate (LVM command)</primary>
      </indexterm>
      <screen><userinput>lvcreate --name bar --size 10G foo</userinput>
<computeroutput>  Logical volume "bar" created</computeroutput></screen>
      Of course, you must complete this command on both nodes of
      your DRBD cluster. After this, you should have a block device
      named <filename>/dev/foo/bar</filename> on either node. </para>
    <para>Then, you can simply enter the newly-created volumes in your
      resource configuration:
      <programlisting>resource r0 {
  ...
  on alice {
    device /dev/drbd0;
    disk   /dev/foo/bar;
    ...
  }
  on bob {
    device /dev/drbd0;
    disk   /dev/foo/bar;
    ...
  }
}</programlisting></para>
    <para>Now you can <link linkend="s-first-time-up">continue to
	bring your resource up</link>, just as you would if you were
      using non-LVM block devices.</para>
  </section>
  <section id="s-lvm-drbd-as-pv">
    <title>Configuring a DRBD resource as a Physical Volume</title>
    <para><indexterm>
      <primary>LVM</primary>
      <secondary>Physical Volume (PV)</secondary>
    </indexterm>
    <indexterm>
      <primary>Physical Volume (LVM)</primary>
    </indexterm>In order to prepare a DRBD resource for use as a Physical
      Volume, it is necessary to create a PV signature on the DRBD
      device. In order to do so, issue one of the following commands
      on the node where the resource is currently in the primary
      role:
      <indexterm>
	<primary>LVM</primary>
	<secondary>pvcreate command</secondary>
      </indexterm>
      <indexterm>
	<primary>pvcreate (LVM command)</primary>
      </indexterm>
      <screen><userinput>pvcreate /dev/drbd<replaceable>num</replaceable></userinput></screen>
      or
      <screen><userinput>pvcreate /dev/drbd/by-res/<replaceable>resource</replaceable></userinput></screen>
    </para>
    <para>Now, it is necessary to include this device in the list of
      devices LVM scans for PV signatures. In order to do this, you
      must edit the LVM configuration file, normally named
      <indexterm>
	<primary>LVM</primary>
	<secondary>lvm.conf (configuration file)</secondary>
      </indexterm>
      <filename>/etc/lvm/lvm.conf</filename>. Find the line in the
      <code>devices</code> section that contains the
      <option>filter</option> keyword and edit it accordingly. If
      <emphasis>all</emphasis> your PVs are to be stored on DRBD
      devices, the following is an appropriate <option>filter</option>
      option:
      <indexterm>
	<primary>LVM</primary>
	<secondary>filter</secondary>
      </indexterm>
      <indexterm>
	<primary>filter expression (LVM)</primary>
      </indexterm>
      <programlisting>filter = [ "a|drbd.*|", "r|.*|" ]</programlisting>
      This filter expression accepts PV signatures found on any
      DRBD devices, while rejecting (ignoring) all others.<note>
	<para>By default, LVM scans all block devices found in
	  <filename>/dev</filename> for PV signatures. This is
	  equivalent to <code>filter = [ "a|.*|" ]</code>.</para>
      </note>
    </para>
    <para>If you want to use stacked resources as LVM PVs, then
      you will need a more explicit filter configuration. You need to
      make sure that LVM detects PV signatures on stacked resources,
      while ignoring them on the corresponding lower-level resources
      and backing devices. This example assumes that your lower-level
      DRBD resources use device minors 0 through 9, whereas your
      stacked resources are using device minors from 10
      upwards:<footnote>
	<para>This is an emerging convention for stacked resources.</para>
      </footnote>
      <programlisting>filter = [ "a|drbd1[0-9]|", "r|.*|" ]</programlisting>
      This filter expression accepts PV signatures found only on the
      DRBD devices <filename>/dev/drbd10</filename> through
      <filename>/dev/drbd19</filename>, while rejecting (ignoring) all
      others.
    </para>
    <para>After modifying the <filename>lvm.conf</filename> file, you
      must run the
      <indexterm>
	<primary>LVM</primary>
	<secondary>vgscan command</secondary>
      </indexterm>
      <indexterm>
	<primary>vgscan (LVM command)</primary>
      </indexterm> <command>vgscan</command> command so LVM discards
      its configuration cache and re-scans devices for PV
      signatures.</para>
    <para>You may of course use a different <option>filter</option>
      configuration to match your particular system configuration.
      What is important to remember, however, is that you need to
      <itemizedlist>
	<listitem>
	  <para>Accept (include) the DRBD devices you wish to use as
	    PVs;</para>
	</listitem>
	<listitem>
	  <para>Reject (exclude) the corresponding lower-level
	    devices, so as to avoid LVM finding duplicate PV
	    signatures.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>In addition, you should disable the LVM cache by setting:
    <programlisting>write_cache_state = 0</programlisting> After
    disabling the LVM cache, make sure you remove any stale cache
    entries by deleting
    <filename>/etc/lvm/cache/.cache</filename>.</para>
    <para>You must repeat the above steps on the peer node.</para>
    <para>When you have configured your new PV, you may proceed to add
    it to a Volume Group, or create a new Volume Group from it. The
    DRBD resource must, of course, be in the primary role while doing
    so.
      <indexterm>
	<primary>LVM</primary>
	<secondary>vgcreate command</secondary>
      </indexterm>
      <indexterm>
	<primary>vgcreate (LVM command)</primary>
      </indexterm>
      <screen><userinput>vgcreate <replaceable>name</replaceable> /dev/drbd<replaceable>num</replaceable></userinput></screen>
      <note>
	<para>While it is possible to mix DRBD and non-DRBD Physical
	Volumes within the same Volume Group, doing so is not
	recommended and unlikely to be of any practical value.</para>
      </note>
    </para>
    <para>When you have created your VG, you may start carving Logical
      Volumes out of it, using the
      <indexterm>
	<primary>LVM</primary>
	<secondary>lvcreate command</secondary>
      </indexterm>
      <indexterm>
	<primary>lvcreate (LVM command)</primary>
      </indexterm>
      <command>lvcreate</command> command
      (as with a non-DRBD-backed Volume Group)</para>
  </section>
  <section id="s-nested-lvm">
    <title>Nested LVM configuration with DRBD</title>
    <para>It is possible, if slightly advanced, to both use
      <indexterm>
	<primary>LVM</primary>
	<secondary>Logical Volume (LV)</secondary>
      </indexterm>
      <indexterm>
	<primary>Logical Volume (LVM)</primary>
      </indexterm> Logical Volumes as backing devices for DRBD
      <emphasis>and</emphasis> at the same time use a DRBD device
      itself as a
      <indexterm>
	<primary>LVM</primary>
	<secondary>Physical Volume (PV)</secondary>
      </indexterm>
      <indexterm>
	<primary>Physical Volume (LVM)</primary>
      </indexterm>Physical Volume. To provide an example, consider
      the following configuration:
	<itemizedlist>
	<listitem>
	  <para>We have two partitions, named
	    <filename>/dev/sda1</filename>, and
	    <filename>/dev/sdb1</filename>, which we intend to use as
	    Physical Volumes.</para>
	</listitem>
	<listitem>
	  <para>Both of these PVs are to become part of a Volume Group
	    named <code>local</code>.</para>
	</listitem>
	<listitem>
	  <para>We want to create a 10-GiB Logical Volume in this VG,
	    to be named <code>r0</code>.
	  </para>
	</listitem>
	<listitem>
	  <para>This LV will become the local backing device for our
	    DRBD resource, also named <code>r0</code>, which
	    corresponds to the device
	    <filename>/dev/drbd0</filename>.</para>
	</listitem>
	<listitem>
	  <para>This device will be the sole PV for another Volume
	    Group, named <code>replicated</code>.</para>
	</listitem>
	<listitem>
	  <para>This VG is to contain two more logical volumes named
	    <code>foo</code> (4 GiB) and <code>bar</code> (6
	    GiB).</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>In order to enable this configuration, follow these
      steps:</para>
    <orderedlist>
      <listitem>
	<para>Set an appropriate <option>filter</option> option in your
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>lvm.conf (configuration file)</secondary>
	  </indexterm>
	  <filename>/etc/lvm/lvm.conf</filename>:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>filter</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>filter expression (LVM)</primary>
	  </indexterm>
	  <programlisting>filter = ["a|sd.*|", "a|drbd.*|", "r|.*|"]</programlisting>
	  This filter expression accepts PV
	  signatures found on any SCSI and DRBD devices, while
	  rejecting (ignoring) all others.</para>
	<para>After modifying the <filename>lvm.conf</filename> file,
	  you must run the
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>vgscan command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vgscan (LVM command)</primary>
	  </indexterm> <command>vgscan</command> command so LVM discards
	  its configuration cache and re-scans devices for PV
	  signatures.</para>
      </listitem>
      <listitem>
	<para>Disable the LVM cache by setting:
	<programlisting>write_cache_state = 0</programlisting>
	</para>
	<para>After disabling the LVM cache, make sure you remove any
	stale cache entries by deleting
	<filename>/etc/lvm/cache/.cache</filename>.</para>
      </listitem>
      <listitem>
	<para>Now, you may initialize your two SCSI partitions as PVs:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>pvcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pvcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>pvcreate /dev/sda1</userinput>
<computeroutput>  Physical volume "/dev/sda1" successfully created</computeroutput>
<userinput>pvcreate /dev/sdb1</userinput>
<computeroutput>  Physical volume "/dev/sdb1" successfully created</computeroutput></screen>
	</para>
      </listitem>
      <listitem>
	<para>The next step is creating your low-level VG named
	  <code>local</code>, consisting of the two PVs you just
	  initialized:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>vgcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vgcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>vgcreate local /dev/sda1 /dev/sda2</userinput>
<computeroutput>  Volume group "local" successfully created</computeroutput></screen>
	</para>
      </listitem>
	<listitem>
	<para>Now you may create your Logical Volume to be used as
	  DRBD's backing device:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>lvcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lvcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>lvcreate --name r0 --size 10G local</userinput>
<computeroutput>  Logical volume "r0" created</computeroutput></screen>
	</para>
      </listitem>
      <listitem>
	<para>Repeat all steps, up to this point, on the peer node.</para>
      </listitem>
      <listitem>
	<para>Then, edit your
	  <filename>/etc/drbd.conf</filename> to create a new resource
	  named <code>r0</code>:
	  <indexterm>
	    <primary>drbd.conf</primary>
	    <secondary>resource</secondary>
	  </indexterm>
	  <programlisting>resource r0 {
  device /dev/drbd0;
  disk /dev/local/r0;
  meta-disk internal;
  on <replaceable>host</replaceable> {
    address <replaceable>address</replaceable>:<replaceable>port</replaceable>;
  }
  on <replaceable>host</replaceable> {
    address <replaceable>address</replaceable>:<replaceable>port</replaceable>;
  }
}</programlisting>
	  After you have created your new resource configuration, be
	  sure to copy your <filename>drbd.conf</filename> contents to
	  the peer node.</para>
      </listitem>
      <listitem>
	<para>After this, initialize your resource as described in
	  <xref linkend="s-first-time-up"/> (on both nodes).</para>
      </listitem>
      <listitem>
	<para>Then, promote your resource (on one node):<indexterm>
	    <primary>drbdadm</primary>
	    <secondary>primary</secondary>
	  </indexterm>
	  <screen><userinput>drbdadm primary r0</userinput></screen>
	</para>
      </listitem>
      <listitem>
	<para>Now, on the node where you just promoted your
	  resource, initialize your DRBD device as a new Physical
	  Volume:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>pvcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pvcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>pvcreate /dev/drbd0</userinput>
<computeroutput>  Physical volume "/dev/drbd0" successfully created</computeroutput></screen>
	</para>
      </listitem>
      <listitem>
	<para>Create your VG named <code>replicated</code>, using
	  the PV you just initialized, on the same node:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>vgcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vgcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>vgcreate replicated /dev/drbd0</userinput>
<computeroutput>  Volume group "replicated" successfully created</computeroutput></screen>
	</para>
      </listitem>
      <listitem>
	<para>Finally, create your new Logical Volumes within this
	  newly-created VG:
	  <indexterm>
	    <primary>LVM</primary>
	    <secondary>lvcreate command</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>lvcreate (LVM command)</primary>
	  </indexterm>
	  <screen><userinput>lvcreate --name foo --size 4G replicated</userinput>
<computeroutput>  Logical volume "foo" created</computeroutput>
<userinput>lvcreate --name bar --size 6G replicated</userinput>
<computeroutput>  Logical volume "bar" created</computeroutput></screen>
	</para>
      </listitem>
    </orderedlist>
    <para>The Logical Volumes <code>foo</code> and <code>bar</code>
      will now be available as
      <filename>/dev/replicated/foo</filename> and
      <filename>/dev/replicated/bar</filename> on the local node.
    </para>
    <para>To make them available on the peer node, first issue the following
      sequence of commands on the local node:
      <indexterm>
	<primary>LVM</primary>
	<secondary>vgchange command</secondary>
      </indexterm>
      <indexterm>
	<primary>vgchange (LVM command)</primary>
      </indexterm>   
      <screen><userinput>vgchange -a n replicated</userinput>
<computeroutput>  0 logical volume(s) in volume group "replicated" now active</computeroutput>
<userinput>drbdadm secondary r0</userinput></screen>
    </para>
    <para>Then, issue these commands on the peer node:
      <indexterm>
	<primary>drbdadm</primary>
	<secondary>primary</secondary>
      </indexterm>
      <indexterm>
	<primary>LVM</primary>
	<secondary>vgchange command</secondary>
      </indexterm>
      <indexterm>
	<primary>vgchange (LVM command)</primary>
      </indexterm>
      <screen><userinput>drbdadm primary r0</userinput>
<userinput>vgchange -a y replicated</userinput>
<computeroutput>  2 logical volume(s) in volume group "replicated" now active</computeroutput></screen>
    After this, the block devices
    <filename>/dev/replicated/foo</filename> and
    <filename>/dev/replicated/bar</filename> will be available on the
    peer node.</para>
    <para>Of course, the process of transferring volume groups between
      peers and making the corresponding logical volumes available can
      be automated.
      <indexterm>
	<primary>LVM</primary>
	<secondary>Heartbeat resource agent</secondary>
      </indexterm>
      <indexterm>
	<primary>Heartbeat</primary>
	<secondary>resource agent</secondary>
	<tertiary>LVM</tertiary>
      </indexterm>
      The Heartbeat <code>LVM</code> resource agent is
      designed for exactly that purpose.</para>
  </section>
</chapter>

[[ch-fundamentals]]
== DRBDの基礎

Distributed Replicated Block Device
(DRBD)は、ストレージのレプリケーション(複製)のためのソフトウェアで、シェアードナッシングを実現します。DRBDはサーバ間でブロックデバイス(ハードディスク、パーティション、論理ボリュームなど)の内容をミラーします。

DRBDによるミラーは、次の特徴を持ちます。

* *リアルタイムレプリケーション* 上位アプリケーションがデバイスのデータを書き換えると、そのデータをリアルタイムでレプリケートします。

* *アプリケーションから透過的* アプリケーションは、データが複数のホスト上に格納されていることを意識する必要はありません。

* *同期* および *非同期* の両方に対応 同期的に動作している場合、すべてのホストのディスクへの書き込みが完了した後で、アプリケーションは完了通知を受け取ります。非同期的に動作している場合は、ローカルディスクへの書き込みが完了したときに、アプリケーションは完了通知を受け取ります。この場合、他のホストへの書き込みは後で行われます。


[[s-kernel-module]]
=== カーネルモジュール

DRBDのコア機能はLinuxのカーネルモジュールとして実装されています。OSのI/Oスタックの一番底に近い場所でDRBDは仮想的なブロックデバイスを作ります。このために、DRBDは非常に柔軟で応用範囲が広く、さまざまなアプリケーションの可用性を高めるために利用できます。

その定義とLinuxカーネルアーキテクチャとの関連にもとづき、DRBDは上位レイヤに関して一切関知しません。このため、DRBDは上位レイヤに対して何らかの機能を付与できません。たとえば、DRBDはファイルシステムの故障を検出できません。またext3やXFSなどのファイルシステムに対してアクティブ-アクティブクラスタ機能を追加することもできません。

[[f-drbd-linux-io-stack]]
.LinuxのI/OスタックでのDRBDの位置
image::images/drbd-in-kernel.svg[]

[[s-userland]]
=== ユーザ空間の管理ツール ===

DRBDにはカーネルモジュールと通信を行う管理ツールがいくつか用意されています。これらのツールを使って、DRBDリソースを設定して管理できます。

.`drbdadm`
DRBDプログラム群における高レベル管理ツールです。このコマンドは、DRBDの制御に必要なすべてのパラメータを `/etc/drbd.conf`
から読み込み、 `drbdsetup` および `drbdmeta` のフロントエンドとして動作します。 `drbdadm` には `-d`
オプションで起動する _dry-run_ モードがあり、実際にコマンドを実行することなく、 `drbdsetup` や `drbdmeta` のどちらが
`drbdadm` を呼び出すのかを表示します。

.`drbdsetup`
カーネルにロードされたDRBDモジュールを設定します。 `drbdsetup` ではすべてのパラメータをコマンドラインで指定する必要があります。
`drbdadm` と `drbdsetup` が分離していると、柔軟性が高くなります。ほとんどのユーザにとって、 `drbdsetup`
を使うことはほとんどないでしょう。

.`drbdmeta`
DRBDメタデータの作成、ダンプ、リストアなどを行うコマンドです。 `drbdsetup` と同様、ほとんどのユーザにとって、 `drbdmeta`
を使うことはほとんどないでしょう。

[[s-resources]]
=== リソース ===

DRBDでは、レプリケートするデータセットに関するさまざまな属性を総称して、リソースと呼びます。リソースは、以下の要素で構成されます。

.リソース名
個々のリソースを区別するために、ホワイトスペース以外のUS-ASCII文字で表される任意の名前を与えることができます。

.ボリューム
どのリソースも、共通のレプリケーションストリームを共有する複数の __ボリューム__
の1つからなる、レプリケーショングループです。DRBDは、リソース内のすべてのボリューム間で書き込みの忠実性が保証されます。ボリュームは `0`
から番号付けされ、1つのリソースにおいて、最大で65,535ボリュームまで可能です。ボリュームにはレプリケートされたデータセットが含まれ、DRBD内部で使用するメタデータのセットも含まれます。

`drbdadm` コマンドでは、リソース内のボリュームを、リソース名とボリューム名を<resource>/<volume>のように記述して指定します。



.DRBDデバイス
DRBDが管理する仮想的なブロックデバイスです。DRBDが管理する仮想的なブロックデバイスで、147のメジャー番号を持ち、minor番号は0から順次割り振られます。各DRBDデバイスは、リソース内の1つのボリュームに該当します。関連付けられたブロックデバイスは通常
`/dev/drbdX` の形式になり、 `X`
はデバイスのminor番号です。DRBDは、ブロックデバイス名をユーザが定義することもできます。その場合は、ブロックデバイス名を `drbd_`
で始まるようにしてください。

NOTE: 初期のバージョンのDRBDは、NBDのデバイスメジャー番号43を勝手に使っていました。47という番号は、DRBDデバイスメジャー番号として、http://www.lanana.org/docs/device-list/[LANANA-registered]に正式に登録されています。

.コネクション
コネクションは、レプリケートされるデータセットを共有する、2つのホスト間の通信リンクです。現時点では、各リソースは2つのホストとこれらのホスト間の1つの接続にのみ関与します。ほとんどの場合、
`resource` と `connection` という用語は同じ意味で使われます。

`drbdadm` では、コネクションはリソース名で指定されます。


[[s-resource-roles]]
=== リソースのロール(役割) ===

DRBDのすべての<<s-resources,リソース>>は、プライマリまたはセカンダリのどちらかのロール(役割)を持っています。

NOTE: 「プライマリ」と「セカンダリ」という用語は適当に選んだものではないことを理解してください。DRBD開発者は意図的に「アクティブ」と「パッシブ」という用語を避けました。プライマリとセカンダリは、ストレージの可用性に関する概念です。一方アクティブとパッシブはアプリケーションの可用性に関わる概念です。ハイアベイラビリティクラスタ環境では、一般的にアクティブノードのDRBDはプライマリになりますが、これが例外のないルールだということではありません。

* プライマリロールのDRBDデバイスでは、データの読み込みと書き込みが制約なく行えます。この状態のストレージに対して、ファイルシステムを作成したりマウントでき、ブロックデバイスに対する下位デバイスI/OやダイレクトI/Oすら可能です。

* セカンダリロールのDRBDデバイスは、対向するノードでのすべてのデータの更新を受け取りますが、自ノードのアプリケーションからのアクセスは、読み込みと書き込みの両方とも一切受け付けません。読み込みすら受け付けない理由は、キャッシュの透過性を保証するためです。もしもセカンダリリソースが自ノードからのアクセスを受け付けると、この保証ができなくなります。

リソースのロールは、もちろん<<s-switch-resource-roles,手動で切り替えできる>>他に、クラスタ管理アプリケーションの何らかのアルゴリズムによって自動で切り替えられます。セカンダリからプライマリへの切り替えを昇格と呼びます。一方プライマリからセダンダリの切り替えは降格と呼びます。
